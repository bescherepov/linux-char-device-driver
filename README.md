# linux-chardevice-driver
Драйвер символьного устройства, позволяющий передавать информацию двум независимым процессам по принципу кольцевого буфера

Установка размера кольцевого буфера происходит через механизм параметров модулей ядра.

Возможны запись, чтение в буфер символьного драйвера. По умолчанию данные операции являются блокирующими, но возможно изменение режима (см. вызовы ioctl).

Операции можно отследить при помощи dmesg. 

Тщательное логирование сделано для проверки работоспособности драйвера и должно быть значительно сокращено на практике.

Вызовы ioctl:
1. Установка блокирующего/неблокирующего режима чтения/записи
2. Получение времени (в секундах от старта ОС) последней операции чтения из буфера
3. Получение идентификатора процесса, выполнившего последнюю операцию чтения
4. Получение времени (в секундах от старта ОС) последней операции чтения из буфера
5. Получение идентификатора процесса, выполнившего последнюю операцию записи
6. Получение идентификатора владельца процесса, выполнившего последнюю операцию чтения
7. Получение идентификатора владельца процесса, выполнившего последнюю операцию записи

## Файлы исходного кода
`scdrv.h` - описание модуля

`buffer.h` - структура кольцевого буфера

`scdrv_io.h` - read, write, open, release, ioctl

## Сборка и установка
`./install.sh`

Скрипт запросит ввод размера буфера драйвера. После этого возможен запрос пароля суперпользователя для установки и настройки модуля.

## Ввод/вывод через консоль

`echo abc > /dev/scdrv0`

`cat /dev/scdrv0`

## Проверка работоспособности драйвера
`ls /dev/scdrv0`

`dmesg` (строки "SCDRV:") 

Логирование почти каждой операции драйвера сделано только для отладки, на практике должно быть значительно сокращено.

## Тестирование
В папке test_programs имеются программы test_read.c, test_ioctl.c, test_write.c для проверки работоспособности драйвера

`gcc test_write.c -o write`

`gcc test_read.c -o read`

`gcc test_ioctl.c -o ioctl`

`./write`

`./read`

`./ioctl`


Установку блокирующего режима можно отследить через dmesg
